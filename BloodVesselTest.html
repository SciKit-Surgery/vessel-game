<!doctype html> 
<html lang="en"> 
<head> 
    <meta charset="UTF-8" />
    <title>Blood Vessel Generation Demo</title>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.16.2/dist/phaser.js"></script>
    <style type="text/css">
        body {
            margin: 0;
        }
    </style>
</head>
<body>

<script type="text/javascript">

	var config = {
		type: Phaser.AUTO,
		width: 612,
		height: 612,
		physics: {
			default: 'arcade',
			arcade: {
				gravity: { y: 300 },
				debug: false
			}
		},
		scene: {
			preload: preload,
			create: create,
			update: update
		}
	};
	
	//GLOBALS
	
	var w = config.width; 				//integer, width of screen
	var h = config.height; 				//integer, height of screen
	
	var standardOffset = 30;			//offset of vessel end points from the edge of the screen
	var endPointSize = 15 				//size of endpoint circles
	var endPointTrueColour = 0x000000; 		//colour of true endpoints (2 of which connect the target blood vessel)
	var endPointFalseColour = 0xffffff; 		//colour of fake endpoints 
	var midPointDisturbance = 100;		//range of disturbance for vessel midpoints
	var splinePoints = 5;				//number of points to draw between endpoints for spline connection
	var vesselColour = 0x87a7b0;			//colour of blood vessel lines
	var vesselThickness = 3; 			//thickness of blood vessels
	
	var game = new Phaser.Game(config);
	
	//CLASS DEFINITIONS
	
		//Point of confusion: Constructors don't appear to be able to set member variables. Javascript vs java thing? Phaser quirk?
	
	class levelParams
	{
		
		/* This class is used to store the parameters which characterize a game level. Instances will be fed into 
		member functions of the level generator class (when that's implemented) to tell it what it needs to
		generate. */
		
		difficulty = 1;				//governs how many blood vessels are placed
		levelType = "FULL"; 			//unused for now, will govern whether the level has restricted FOV and the mosaicing effect.
		
		SetParams(d) 				//I would set this through a constructor instead, but for whatever reason it doesn't work, I have to create a default levelParams and then call this.
		{
									
			
			this.difficulty = d;
		}

	}
	
	class point
	
	{
		x = 0;
		y = 0;
		
		SetCoordinates(newX,newY)
		{
			this.x = newX;
			this.y = newY;
		}
	}
	
	class vesselCoordinates
	
	{

		//Point 1
		point1 = new point;
		//Point 2
		point2 = new point;
		
		vesselCoordinates(a,b,c,d) 
		{
			
		//Known issue: this constructor doesn't actually work for the time being. Use SetCoordinates after creating instance or coords will always be default.
		
		this.point1.x = a;
		this.point1.y = b;
		this.point2.x = c;
		this.point2.y = d;
			
		}
		
		SetCoordinates(a,b,c,d)
		{
			
		//Sets coordinates for the blood vessel's endpoints. 
		
		this.point1.x = a;
		this.point1.y = b;	
		this.point2.x = c;
		this.point2.y = d;
		
		}
		
			
	}
	
	class bloodVessel
	
	{
		endPoints = [];
		midPoints = [];
		endCol1 = 0x000000;
		endCol2 = 0x000000;
		
		setEndPoints(newEnds)
		
		{
			this.endPoints = newEnds;
		}
		
		setMidPoints(newMids)
		{
			this.midPoints = newMids;
		}
		
		setEndCol1(newCol)
		{
			this.endCol1 = newCol;
		}
		
		setEndCol2(newCol)
		{
			this.endCol2 = newCol;
		}
		
		disturbMidPoints(maximum)
		{
			for (var i = 0;i<midPoints.length;i++)
			{
				midPoints[i].x += Phaser.Math.Between(-maximum,maximum);
				midPoints[i].y += Phaser.Math.Between(-maximum,maximum);
				
				if (Math.abs(midPoints[i].x) >= w)
					{
						if (midPoints[i].x > 0)
						{
							midPoints[i].x -= w;
						}
						
						else
						{
							midPoints[i].x += w;
						}
					}
			}
		}
		
		drawLines(scene,graphics)
		{
			
			scene.add.circle(endPoints.point1.x,endPoints.point1.y, endPointSize, this.endCol1, 1);
			scene.add.circle(endPoints.point2.x,endPoints.point2.y, endPointSize, this.endCol2, 1); 
			
			for (var i = 0;i<midPoints.length;i++) 
			{
				scene.add.circle(midPoints[i].x,midPoints[i].y,vesselThickness * 2,vesselColour,1);
				console.log("Drew Midpoint At " + midPoints[i].x  + "," +  midPoints[i].y);
			}
			
			var splinePoints = [];
			
			for (var i = 0;i<midPoints.length;i++)
			{
				splinePoints.push(midPoints[i].x);
				splinePoints.push(midPoints[i].y);
			}
			
			splinePoints.unshift(endPoints.point1.y);
			splinePoints.unshift(endPoints.point1.x);
			
			splinePoints.push(endPoints.point2.x);
			splinePoints.push(endPoints.point2.y);
			
			console.log(splinePoints);
			
			let splineX = (splinePoints[0] + splinePoints[splinePoints.length-2])/2;
			let splineY = (splinePoints[1] + splinePoints[splinePoints.length-1])/2;
			console.log("Spline center:" + splineX + "," + splineY);
			const splineCurve = new Phaser.Curves.Spline(splinePoints);
			let splineObject = scene.add.curve(splineX,splineY,splineCurve);
			
			splineCurve.draw(graphics);
		}
	}

	class pointGenerator // This class's purpose is to generate a pair of points within a specified screen boundary. 
	{

		
		//below members define the area the generator draws points within. Screen size with offset buffer by default.
		
		boundaryX1 = standardOffset;
		boundaryX2 = w - standardOffset;
		boundaryY1 = standardOffset;
		boundaryY2 = h - standardOffset;
		
		pointGenerator(a,b,c,d,o)
		{
		//constructor, allows assignment of boundary variables. Doesn't work, like all constructors in this program.
			
			this.boundaryX1 = a;
			this.boundaryX2 = b;
			this.boundaryY1 = c;
			this.boundaryY2 = d;
		}
		
		GenerateEndPoints()
		{
			
			//randomly generates two endpoints for a vessel and returns their coordinates as a VesselCoordinates object instance
			
			var coords = new vesselCoordinates();
			
			var whichEdge = Phaser.Math.Between(1,2);	//Flips a coin to determine whether the vessel is generated spanning top and bottom, or left and right
			
			switch(whichEdge)
			{
				case 1: //Top and bottom

				
				coords.SetCoordinates(
				Phaser.Math.Between(this.boundaryX1,this.boundaryX2), 			//X1
				this.boundaryY1, 							//Y1
				Phaser.Math.Between(this.boundaryX1,this.boundaryX2), 			//X2
				this.boundaryY2								//Y2
				);
				
				
				break;
				
				case 2: //Left and right

				
				coords.SetCoordinates( 											
				this.boundaryX1,							//X1
				Phaser.Math.Between(this.boundaryY1,this.boundaryY2),			//Y1
				this.boundaryX2,							//X2
				Phaser.Math.Between(this.boundaryY1,this.boundaryY2)			//Y2
				);
				
				break;
				
				default:
				
				coords.SetCoordinates(0,0,0,0);
				
				break;

			}
			
			return coords; 
			
		}
		
		GenerateMidPoints(coords)
		{
			//Given a vesselCoordinates, returns an array of n evenly spaced points between the endpoints.
			var pointArray = [];
			
			var newX = 0;
			var newY = 0;
			
			console.log("GENERATING VESSEL MIDPOINTS");

			for (var i = 1;2*i <= splinePoints * 2;i++)
			{
			
				console.log("LOOP CONTINUES");
				
				var stepX = Math.abs(coords.point2.x-coords.point1.x)/(splinePoints+1);
				var stepY = Math.abs(coords.point2.y-coords.point1.y)/(splinePoints+1);
				
				if (coords.point1.x > coords.point2.x)
				{
					stepX *= -1;
				}
				
				if (coords.point1.y > coords.point2.y)
				{
					stepY *= -1;
				}
			
				newX = coords.point1.x + (i*stepX); 
				newY = coords.point1.y + (i*stepY);
				var newPoint = new point();
				newPoint.SetCoordinates(newX,newY);
				
				pointArray.push(newPoint);
				
			} 
			
			
			return pointArray;
			
		}
	}
	
	function GenerateVessel(target)
	{
		
		//Creates a blood vessel for the target scene, between points created by a pointGenerator.
		//returns the blood vessel object.
		
		var endCol1 = endPointFalseColour; 		// colour of first point placed
		var endCol2 = endPointFalseColour; 		// colour of second point placed
		
		if (target)					// ensures the target vessel has 2 "true" ends.
		{
			endCol1 = endPointTrueColour;
			endCol2 = endPointTrueColour;
		}
			
		else
		{
			if (Phaser.Math.Between(1,3) == 3) 	//1 in 3 chance of decoy vessel having one "true" end 
			{
				endCol1 = endPointTrueColour;
			}
		}
			
		generator = new pointGenerator();
		endPoints = generator.GenerateEndPoints(); //array containing the end points
		midPoints = generator.GenerateMidPoints(endPoints); //array containing the mid points


		newVessel = new bloodVessel;
		newVessel.setEndPoints(endPoints);
		newVessel.setMidPoints(midPoints);
		newVessel.endCol1 = endCol1;
		newVessel.endCol2 = endCol2;
		newVessel.disturbMidPoints(midPointDisturbance);
			
		//works up until  here, midPoints seems to become undefined afterwards
			
		return newVessel;
		
	}

	function preload()
	{
		defaultScene = this;

		this.load.image('blood', 'assets/blood.jpg');

	}

	function create ()
	{
		//PERMANENT GRAPHICS
		//Shouldn't be deleted when the scene is cleared.
		this.add.image(w/2, h/2, 'blood');
		
		//VESSEL GRAPHICS
		let vesselGraphics = this.add.graphics(w/2,h/2);
		vesselGraphics.lineStyle(5, vesselColour, 1.0);
		vesselGraphics.fillStyle(vesselColour, 1.0);
		
		//TESTING BLOCK
		//For now, this section is used to test generation.
		
		var testParams = new levelParams();
		testParams.SetParams(Phaser.Math.Between(1,5),"FULL");
		
		this.add.text(w/2, h/2, "Difficulty: " + testParams.difficulty, { fontFamily: 'Georgia, "Goudy Bookletter 1911", Times, serif' });
		

		for (var i = 0;i < testParams.difficulty;i++)
		{
			var targetVessel = (i == testParams.difficulty - 1) ? (true) : (false); //If this is the last vessel to be placed, tells PlaceVessel that it needs to be real
		
			var newVessel = GenerateVessel(targetVessel);
			
			newVessel.drawLines(this,vesselGraphics);

		}
		
		
	}

	function update ()
	{
	}
	


</script>

</body>
</html>
